set previewer lf-kitty-previewer
set cleaner lf-kitty-cleaner

map <c-f> $lf -remote "send $id select \"$(fzf)\""
map J $lf -remote "send $id cd $(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf)"

# Unbind key
map r
map d
map y
map p
map e
map M
map [
map ]

#use '<delete>' key for either 'trash' or 'delete' command
map <delete> trash
map DD delete
map dr restore_trash

# mkdir command. See wiki if you want it to select created dir
map <f-7> :push %mkdir<space>
map <insert> :push %touch<space>
map U explore
map [e extract
map [z zipf
map [Z zipfullpath
map [t tar
map [w $wine "$f"

# Basic Functions
#map . set hidden!
map <backspace2> set hidden!
map e $nvr $f
map E $code $f
map r refresh
#map o $st -e /bin/zsh -c "$(pwd); exec /bin/zsh" &
map o $tmux new-window -c "$(pwd)"
map pp paste
map po pasteoverwrite
map dd cut
map du calcfoldersize
map dt moveto
map yy copy
map yt copyto
map yp copyfilepath
map yd copydirname
map yn copyfilename
map <f-2> rename
map <f-3> open_image_gallery

map A rename # at the very end
map C push A<a-b><a-b><a-f><c-u>  # new rename
map I push A<c-a> # at the very beginning
map i push A<a-b><a-b><a-f> # before extension
map a push A<a-b> # after extension
map B bulkrename
map b $setbg $f
#map C clear
map zp toggle_preview

# Jumping around
map H     jump-prev
map L     jump-next


# Movement
map gE cd /etc
map gU cd /usr
map gO cd /opt
map gV cd /var
map gM cd /mnt
map gS cd /srv
map g/ cd /
map gt cd ~/.local/share/Trash/files

map gC cd ~/Dropbox/Coding
map gD cd ~/github/dotfile
map gG cd ~/github
map gP cd ~/Dropbox/MyProject
map gS cd ~/github/suckless/st
map ga cd ~/Dropbox/Dataon/
map gb cd ~/.local/bin
map gc cd ~/.config
map gd cd ~/Dropbox
map ge cd ~/Desktop
map gf cd ~/files
map gl cd ~/Dropbox/linux
map gm cd ~/marc
map gn cd ~/Dropbox/notes
map go cd ~/Downloads
map gp cd ~/Dropbox/Dataon/Project
map gs cd ~/.script
map gr cd ~/Dropbox/MyProject/react-app-src

map g1 $veracrypt -t -k "" --pim=0 --protect-hidden=no ~/Dropbox/linux/cl ~/.script
map g2 $sudo sshfs -o allow_other,default_permissions -p 5553 root@101.255.94.130:/ /mnt/multirasa-app/
map g3 $sudo sshfs -o allow_other,default_permissions -p 5151 root@101.255.94.130:/ /mnt/multirasa-db/

map g0 $veracrypt -t -k "" --pim=0 --protect-hidden=no ~/Documents/file ~/mnt
# interpreter for shell commands
set shell sh

# Basic Settings
set ignorecase true
set icons true
%[ $LF_LEVEL -eq 1 ] || echo "Warning: You're in a nested lf instance!"

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
set scrolloff 10

# Use the `dim` attribute instead of underline for the cursor in the preview pane
# set cursorpreviewfmt "\033[7;2m"

# show the result of execution of previous commands
map ` !true

# execute current file (must be executable)
map x $$f
map X !$f

# dedicated keys for file opener actions
# map o &mimeopen $f
# map O $mimeopen --ask $f


# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open &{{
	case "$f" in
        *.tar*) tar tf "$f";;&
        *.zip) unzip -l "$f";;&
        *.rar) unrar l "$f";;&
        *.7z) 7z l "$f";;&
        *.pdf) lf -remote "send $id \$zathura \$fx &";;
        *.xls*|*.ppt*|*.doc*) libreoffice "$fx" -;;
        #*.xls*) et "$fx" -;;
        #*.ppt*) wpp "$fx" -;;
        #*.doc*) wps "$fx" -;;
        *.png|*.jpg|*.jpeg|*.webp) feh "$fx" -;;
        *.mp4|*.mkv|*.webm) mpv --loop "$fx" -;;
        *.mp3) mocp -le "$fx" -;; *) lf -remote "send $id \$$EDITOR \$fx";;
    esac

    #case $(file --mime-type -Lb $f) in
	#	#text/*) lf -remote "send $id \$$EDITOR \$fx";;
	#	text/*) lf -remote "send $id \$nvim -l \$fx";;
    #    inode/x-empty) lf -remote "send $id \$$EDITOR \$fx";;
	#	application/pdf) lf -remote "send $id \$zathura \$fx";; 
    #    *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
    #esac
}}

map <enter> open

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

# make sure trash folder exists
# %mkdir -p ~/.trash

# Trash bindings
cmd trash ${{
  files=$(printf "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    file=${files%%;*}

    trash-put "$(basename "$file")"
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done
}}
cmd restore_trash ${{
	  trash-restore
}}

# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)
# cmd trash %set -f; mv $fx ~/.trash

# define a custom 'delete' command
cmd delete ${{
    set -f
    printf "$fx\n"
    printf "delete?[y/n]"
    read ans
    [ "$ans" = "y" ] && rm -rf $fx
}}

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;\
		*) echo "Unsupported format" ;;
    esac
	notify-send "File extraction completed" "$f" -u low
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zipf ${{
    set -f
	if test "$f" = "$fx"
	then
		echo "eq"
		zname=$(basename "$f")
		zip $zname.zip $zname
	else
		echo "neq"
		zname=$(basename "$(pwd)")
		mkdir $zname
		cp -r $fx $zname
		zip -r $zname.zip $zname
		rm -rf $zname
	fi
	lf -remote 'send unselect'
	notify-send "File(s) zip completed" "$f" -u low
}}

cmd zipfullpath %{{
    set -f
	if test "$f" = "$fx"
	then
		echo "eq"
		zip $f.zip $f
	else
		echo "neq"
		zname=$(basename "$(pwd)")
		zip -r $zname.zip $fx
	fi
	lf -remote 'send unselect'
	notify-send "File(s) zip completed" "$f" -u low
}}

cmd copyfilename ${{
	set -f
	file_name="$(basename $f)"
	echo -n $file_name | wl-copy
	notify-send "File name copied successfully" "$file_name" -u low
}}

cmd copydirname ${{
	dir_name="$(pwd)"
	echo -n $dir_name | wl-copy
	notify-send "Directory name copied successfully" "$dir_name" -u low
}}

cmd copyfilepath ${{
    set -f
	if test "$f" = "$fx"
	then
		echo -n $f | wl-copy
		notify-send "File path copied successfully" "$f" -u low
	else
		echo -n $fx | wl-copy
		notify-send "File path copied successfully" "$fx" -u low
	fi
	lf -remote 'send clear'
}}

cmd pasteoverwrite %{{
	load=$(cat ~/.local/share/lf/files)
	mode=$(echo "$load" | sed -n '1p')
	list=$(echo "$load" | sed '1d')
	if [ $mode = 'copy' ]; then
		cp -R $list .
	elif [ $mode = 'move' ]; then
		mv $list .
		rm ~/.local/share/lf/files
		lf -remote 'send clear'
	fi
	notify-send "ðŸ’¾ File(s) copied successfully" "$fx" -u low
}}

cmd open_image_gallery ${{
	set -f
	gallery_path=$(pwd)
	kitty -e sxiv -tf $gallery_path
}}

cmd calcfoldersize ${{
	set -f
	lf -remote 'send calcdirsize'
	lf -remote 'send unselect'
}}

cmd bulkrename ${{
	set -f
	thunar -B $fx
	lf -remote 'send unselect'
}}

cmd refresh ${{
	lf -remote 'send reload'
	lf -remote 'send redraw'
}}

cmd pastenotify ${{
	lf -remote 'send paste'
	notify-send "ðŸ’¾ File(s) Copied Successfully." "$fx"
}}

cmd explore ${{
	set -f
	current_dir=$(pwd)
	lf -remote "send $id \$thunar \$fx &"
	#thunar $current_dir &
}}

cmd moveto ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Move to where?"
	dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	notify-send "ðŸšš File(s) moved." "File(s) moved to $dest."
}}

cmd copyto ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Copy to where?"
	dest="$(sed -e 's/\s*#.*//' -e '/^$/d' -e 's/^\S*\s*//' ${XDG_CONFIG_HOME:-$HOME/.config}/shell/bm-dirs | fzf | sed 's|~|$HOME|')" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	notify-send "ðŸ“‹ File(s) copied." "File(s) copies to $dest."
}}

cmd toggle_preview %{{
    if [ "$lf_preview" = "true" ]; then
		lf_preview="false"
        lf -remote "send $id :set nopreview; set ratios 1; set info size:time"
    else
		lf_preview="true"
        lf -remote "send $id :set preview; set ratios 3:3"
    fi
}}

